{"version":3,"file":"index.umd.js","sources":["../src/utilities/colStyle.ts","../src/TableView.ts","../src/utilities/createColGroup.ts","../src/utilities/createCell.ts","../src/utilities/getTableNodeTypes.ts","../src/utilities/createTable.ts","../src/utilities/isCellSelection.ts","../src/utilities/deleteTableWhenAllCellsSelected.ts","../src/table.ts"],"sourcesContent":["export function getColStyleDeclaration(minWidth: number, width: number | undefined): [string, string] {\n  if (width) {\n    // apply the stored width unless it is below the configured minimum cell width\n    return ['width', `${Math.max(width, minWidth)}px`]\n  }\n\n  // set the minimum with on the column if it has no stored width\n  return ['min-width', `${minWidth}px`]\n\n}\n","import { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { NodeView, ViewMutationRecord } from '@tiptap/pm/view'\n\nimport { getColStyleDeclaration } from './utilities/colStyle.js'\n\nexport function updateColumns(\n  node: ProseMirrorNode,\n  colgroup: HTMLTableColElement, // <colgroup> has the same prototype as <col>\n  table: HTMLTableElement,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n) {\n  let totalWidth = 0\n  let fixedWidth = true\n  let nextDOM = colgroup.firstChild\n  const row = node.firstChild\n\n  if (row !== null) {\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n      const { colspan, colwidth } = row.child(i).attrs\n\n      for (let j = 0; j < colspan; j += 1, col += 1) {\n        const hasWidth = overrideCol === col ? overrideValue : (colwidth && colwidth[j]) as number | undefined\n        const cssWidth = hasWidth ? `${hasWidth}px` : ''\n\n        totalWidth += hasWidth || cellMinWidth\n\n        if (!hasWidth) {\n          fixedWidth = false\n        }\n\n        if (!nextDOM) {\n          const colElement = document.createElement('col')\n\n          const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n          colElement.style.setProperty(propertyKey, propertyValue)\n\n          colgroup.appendChild(colElement)\n        } else {\n          if ((nextDOM as HTMLTableColElement).style.width !== cssWidth) {\n            const [propertyKey, propertyValue] = getColStyleDeclaration(cellMinWidth, hasWidth);\n\n            (nextDOM as HTMLTableColElement).style.setProperty(propertyKey, propertyValue)\n          }\n\n          nextDOM = nextDOM.nextSibling\n        }\n      }\n    }\n  }\n\n  while (nextDOM) {\n    const after = nextDOM.nextSibling\n\n    nextDOM.parentNode?.removeChild(nextDOM)\n    nextDOM = after\n  }\n\n  if (fixedWidth) {\n    table.style.width = `${totalWidth}px`\n    table.style.minWidth = ''\n  } else {\n    table.style.width = ''\n    table.style.minWidth = `${totalWidth}px`\n  }\n}\n\nexport class TableView implements NodeView {\n  node: ProseMirrorNode\n\n  cellMinWidth: number\n\n  dom: HTMLDivElement\n\n  table: HTMLTableElement\n\n  colgroup: HTMLTableColElement\n\n  contentDOM: HTMLTableSectionElement\n\n  constructor(node: ProseMirrorNode, cellMinWidth: number) {\n    this.node = node\n    this.cellMinWidth = cellMinWidth\n    this.dom = document.createElement('div')\n    this.dom.className = 'tableWrapper'\n    this.table = this.dom.appendChild(document.createElement('table'))\n    this.colgroup = this.table.appendChild(document.createElement('colgroup'))\n    updateColumns(node, this.colgroup, this.table, cellMinWidth)\n    this.contentDOM = this.table.appendChild(document.createElement('tbody'))\n  }\n\n  update(node: ProseMirrorNode) {\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    this.node = node\n    updateColumns(node, this.colgroup, this.table, this.cellMinWidth)\n\n    return true\n  }\n\n  ignoreMutation(mutation: ViewMutationRecord) {\n    return (\n      mutation.type === 'attributes'\n      && (mutation.target === this.table || this.colgroup.contains(mutation.target))\n    )\n  }\n}\n","import { DOMOutputSpec, Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport { getColStyleDeclaration } from './colStyle.js'\n\nexport type ColGroup = {\n  colgroup: DOMOutputSpec\n  tableWidth: string\n  tableMinWidth: string\n} | Record<string, never>;\n\n/**\n * Creates a colgroup element for a table node in ProseMirror.\n *\n * @param node - The ProseMirror node representing the table.\n * @param cellMinWidth - The minimum width of a cell in the table.\n * @param overrideCol - (Optional) The index of the column to override the width of.\n * @param overrideValue - (Optional) The width value to use for the overridden column.\n * @returns An object containing the colgroup element, the total width of the table, and the minimum width of the table.\n */\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n): ColGroup\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n  overrideCol: number,\n  overrideValue: number,\n): ColGroup\nexport function createColGroup(\n  node: ProseMirrorNode,\n  cellMinWidth: number,\n  overrideCol?: number,\n  overrideValue?: number,\n): ColGroup {\n  let totalWidth = 0\n  let fixedWidth = true\n  const cols: DOMOutputSpec[] = []\n  const row = node.firstChild\n\n  if (!row) {\n    return {}\n  }\n\n  for (let i = 0, col = 0; i < row.childCount; i += 1) {\n    const { colspan, colwidth } = row.child(i).attrs\n\n    for (let j = 0; j < colspan; j += 1, col += 1) {\n      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j] as number | undefined\n\n      totalWidth += hasWidth || cellMinWidth\n\n      if (!hasWidth) {\n        fixedWidth = false\n      }\n\n      const [property, value] = getColStyleDeclaration(cellMinWidth, hasWidth)\n\n      cols.push([\n        'col',\n        { style: `${property}: ${value}` },\n      ])\n    }\n  }\n\n  const tableWidth = fixedWidth ? `${totalWidth}px` : ''\n  const tableMinWidth = fixedWidth ? '' : `${totalWidth}px`\n\n  const colgroup: DOMOutputSpec = ['colgroup', {}, ...cols]\n\n  return { colgroup, tableWidth, tableMinWidth }\n}\n","import { Fragment, Node as ProsemirrorNode, NodeType } from '@tiptap/pm/model'\n\nexport function createCell(\n  cellType: NodeType,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode | null | undefined {\n  if (cellContent) {\n    return cellType.createChecked(null, cellContent)\n  }\n\n  return cellType.createAndFill()\n}\n","import { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getTableNodeTypes(schema: Schema): { [key: string]: NodeType } {\n  if (schema.cached.tableNodeTypes) {\n    return schema.cached.tableNodeTypes\n  }\n\n  const roles: { [key: string]: NodeType } = {}\n\n  Object.keys(schema.nodes).forEach(type => {\n    const nodeType = schema.nodes[type]\n\n    if (nodeType.spec.tableRole) {\n      roles[nodeType.spec.tableRole] = nodeType\n    }\n  })\n\n  schema.cached.tableNodeTypes = roles\n\n  return roles\n}\n","import { Fragment, Node as ProsemirrorNode, Schema } from '@tiptap/pm/model'\n\nimport { createCell } from './createCell.js'\nimport { getTableNodeTypes } from './getTableNodeTypes.js'\n\nexport function createTable(\n  schema: Schema,\n  rowsCount: number,\n  colsCount: number,\n  withHeaderRow: boolean,\n  cellContent?: Fragment | ProsemirrorNode | Array<ProsemirrorNode>,\n): ProsemirrorNode {\n  const types = getTableNodeTypes(schema)\n  const headerCells: ProsemirrorNode[] = []\n  const cells: ProsemirrorNode[] = []\n\n  for (let index = 0; index < colsCount; index += 1) {\n    const cell = createCell(types.cell, cellContent)\n\n    if (cell) {\n      cells.push(cell)\n    }\n\n    if (withHeaderRow) {\n      const headerCell = createCell(types.header_cell, cellContent)\n\n      if (headerCell) {\n        headerCells.push(headerCell)\n      }\n    }\n  }\n\n  const rows: ProsemirrorNode[] = []\n\n  for (let index = 0; index < rowsCount; index += 1) {\n    rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells))\n  }\n\n  return types.table.createChecked(null, rows)\n}\n","import { CellSelection } from '@tiptap/pm/tables'\n\nexport function isCellSelection(value: unknown): value is CellSelection {\n  return value instanceof CellSelection\n}\n","import { findParentNodeClosestToPos, KeyboardShortcutCommand } from '@tiptap/core'\n\nimport { isCellSelection } from './isCellSelection.js'\n\nexport const deleteTableWhenAllCellsSelected: KeyboardShortcutCommand = ({ editor }) => {\n  const { selection } = editor.state\n\n  if (!isCellSelection(selection)) {\n    return false\n  }\n\n  let cellCount = 0\n  const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n    return node.type.name === 'table'\n  })\n\n  table?.node.descendants(node => {\n    if (node.type.name === 'table') {\n      return false\n    }\n\n    if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n      cellCount += 1\n    }\n  })\n\n  const allCellsSelected = cellCount === selection.ranges.length\n\n  if (!allCellsSelected) {\n    return false\n  }\n\n  editor.commands.deleteTable()\n\n  return true\n}\n","import {\n  callOrReturn, getExtensionField, mergeAttributes, Node, ParentConfig,\n} from '@tiptap/core'\nimport { DOMOutputSpec, Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport {\n  addColumnAfter,\n  addColumnBefore,\n  addRowAfter,\n  addRowBefore,\n  CellSelection,\n  columnResizing,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  fixTables,\n  goToNextCell,\n  mergeCells,\n  setCellAttr,\n  splitCell,\n  tableEditing,\n  toggleHeader,\n  toggleHeaderCell,\n} from '@tiptap/pm/tables'\nimport { EditorView, NodeView } from '@tiptap/pm/view'\n\nimport { TableView } from './TableView.js'\nimport { createColGroup } from './utilities/createColGroup.js'\nimport { createTable } from './utilities/createTable.js'\nimport { deleteTableWhenAllCellsSelected } from './utilities/deleteTableWhenAllCellsSelected.js'\n\nexport interface TableOptions {\n  /**\n   * HTML attributes for the table element.\n   * @default {}\n   * @example { class: 'foo' }\n   */\n  HTMLAttributes: Record<string, any>\n\n  /**\n   * Enables the resizing of tables.\n   * @default false\n   * @example true\n   */\n  resizable: boolean\n\n  /**\n   * Controls whether the table wrapper for the resizable node view should be rendered in\n   * non-editable mode as well.\n   * @default false\n   * @example true\n   */\n  renderWrapper: boolean\n\n  /**\n   * The width of the resize handle.\n   * @default 5\n   * @example 10\n   */\n  handleWidth: number\n\n  /**\n   * The minimum width of a cell.\n   * @default 25\n   * @example 50\n   */\n  cellMinWidth: number\n\n  /**\n   * The node view to render the table.\n   * @default TableView\n   */\n  View: (new (node: ProseMirrorNode, cellMinWidth: number, view: EditorView) => NodeView) | null\n\n  /**\n   * Enables the resizing of the last column.\n   * @default true\n   * @example false\n   */\n  lastColumnResizable: boolean\n\n  /**\n   * Allow table node selection.\n   * @default false\n   * @example true\n   */\n  allowTableNodeSelection: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    table: {\n      /**\n       * Insert a table\n       * @param options The table attributes\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.insertTable({ rows: 3, cols: 3, withHeaderRow: true })\n       */\n      insertTable: (options?: {\n        rows?: number\n        cols?: number\n        withHeaderRow?: boolean\n      }) => ReturnType\n\n      /**\n       * Add a column before the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addColumnBefore()\n       */\n      addColumnBefore: () => ReturnType\n\n      /**\n       * Add a column after the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addColumnAfter()\n       */\n      addColumnAfter: () => ReturnType\n\n      /**\n       * Delete the current column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteColumn()\n       */\n      deleteColumn: () => ReturnType\n\n      /**\n       * Add a row before the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addRowBefore()\n       */\n      addRowBefore: () => ReturnType\n\n      /**\n       * Add a row after the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.addRowAfter()\n       */\n      addRowAfter: () => ReturnType\n\n      /**\n       * Delete the current row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteRow()\n       */\n      deleteRow: () => ReturnType\n\n      /**\n       * Delete the current table\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.deleteTable()\n       */\n      deleteTable: () => ReturnType\n\n      /**\n       * Merge the currently selected cells\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.mergeCells()\n       */\n      mergeCells: () => ReturnType\n\n      /**\n       * Split the currently selected cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.splitCell()\n       */\n      splitCell: () => ReturnType\n\n      /**\n       * Toggle the header column\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderColumn()\n       */\n      toggleHeaderColumn: () => ReturnType\n\n      /**\n       * Toggle the header row\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderRow()\n       */\n      toggleHeaderRow: () => ReturnType\n\n      /**\n       * Toggle the header cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.toggleHeaderCell()\n       */\n      toggleHeaderCell: () => ReturnType\n\n      /**\n       * Merge or split the currently selected cells\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.mergeOrSplit()\n       */\n      mergeOrSplit: () => ReturnType\n\n      /**\n       * Set a cell attribute\n       * @param name The attribute name\n       * @param value The attribute value\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.setCellAttribute('align', 'right')\n       */\n      setCellAttribute: (name: string, value: any) => ReturnType\n\n      /**\n       * Moves the selection to the next cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.goToNextCell()\n       */\n      goToNextCell: () => ReturnType\n\n      /**\n       * Moves the selection to the previous cell\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.goToPreviousCell()\n       */\n      goToPreviousCell: () => ReturnType\n\n      /**\n       * Try to fix the table structure if necessary\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.fixTables()\n       */\n      fixTables: () => ReturnType\n\n      /**\n       * Set a cell selection inside the current table\n       * @param position The cell position\n       * @returns True if the command was successful, otherwise false\n       * @example editor.commands.setCellSelection({ anchorCell: 1, headCell: 2 })\n       */\n      setCellSelection: (position: { anchorCell: number; headCell?: number }) => ReturnType\n    }\n  }\n\n  interface NodeConfig<Options, Storage> {\n    /**\n     * A string or function to determine the role of the table.\n     * @default 'table'\n     * @example () => 'table'\n     */\n    tableRole?:\n      | string\n      | ((this: {\n      name: string\n      options: Options\n      storage: Storage\n      parent: ParentConfig<NodeConfig<Options>>['tableRole']\n    }) => string)\n  }\n}\n\n/**\n * This extension allows you to create tables.\n * @see https://www.tiptap.dev/api/nodes/table\n */\nexport const Table = Node.create<TableOptions>({\n  name: 'table',\n\n  // @ts-ignore\n  addOptions() {\n    return {\n      HTMLAttributes: {},\n      resizable: false,\n      renderWrapper: false,\n      handleWidth: 5,\n      cellMinWidth: 25,\n      // TODO: fix\n      View: TableView,\n      lastColumnResizable: true,\n      allowTableNodeSelection: false,\n    }\n  },\n\n  content: 'tableRow+',\n\n  tableRole: 'table',\n\n  isolating: true,\n\n  group: 'block',\n\n  parseHTML() {\n    return [{ tag: 'table' }]\n  },\n\n  renderHTML({ node, HTMLAttributes }) {\n    const { colgroup, tableWidth, tableMinWidth } = createColGroup(\n      node,\n      this.options.cellMinWidth,\n    )\n\n    const table: DOMOutputSpec = [\n      'table',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n        style: tableWidth\n          ? `width: ${tableWidth}`\n          : `min-width: ${tableMinWidth}`,\n      }),\n      colgroup,\n      ['tbody', 0],\n    ]\n\n    return this.options.renderWrapper ? ['div', { class: 'tableWrapper' }, table] : table\n  },\n\n  addCommands() {\n    return {\n      insertTable:\n        ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\n          const node = createTable(editor.schema, rows, cols, withHeaderRow)\n\n          if (dispatch) {\n            const offset = tr.selection.from + 1\n\n            tr.replaceSelectionWith(node)\n              .scrollIntoView()\n              .setSelection(TextSelection.near(tr.doc.resolve(offset)))\n          }\n\n          return true\n        },\n      addColumnBefore:\n        () => ({ state, dispatch }) => {\n          return addColumnBefore(state, dispatch)\n        },\n      addColumnAfter:\n        () => ({ state, dispatch }) => {\n          return addColumnAfter(state, dispatch)\n        },\n      deleteColumn:\n        () => ({ state, dispatch }) => {\n          return deleteColumn(state, dispatch)\n        },\n      addRowBefore:\n        () => ({ state, dispatch }) => {\n          return addRowBefore(state, dispatch)\n        },\n      addRowAfter:\n        () => ({ state, dispatch }) => {\n          return addRowAfter(state, dispatch)\n        },\n      deleteRow:\n        () => ({ state, dispatch }) => {\n          return deleteRow(state, dispatch)\n        },\n      deleteTable:\n        () => ({ state, dispatch }) => {\n          return deleteTable(state, dispatch)\n        },\n      mergeCells:\n        () => ({ state, dispatch }) => {\n          return mergeCells(state, dispatch)\n        },\n      splitCell:\n        () => ({ state, dispatch }) => {\n          return splitCell(state, dispatch)\n        },\n      toggleHeaderColumn:\n        () => ({ state, dispatch }) => {\n          return toggleHeader('column')(state, dispatch)\n        },\n      toggleHeaderRow:\n        () => ({ state, dispatch }) => {\n          return toggleHeader('row')(state, dispatch)\n        },\n      toggleHeaderCell:\n        () => ({ state, dispatch }) => {\n          return toggleHeaderCell(state, dispatch)\n        },\n      mergeOrSplit:\n        () => ({ state, dispatch }) => {\n          if (mergeCells(state, dispatch)) {\n            return true\n          }\n\n          return splitCell(state, dispatch)\n        },\n      setCellAttribute:\n        (name, value) => ({ state, dispatch }) => {\n          return setCellAttr(name, value)(state, dispatch)\n        },\n      goToNextCell:\n        () => ({ state, dispatch }) => {\n          return goToNextCell(1)(state, dispatch)\n        },\n      goToPreviousCell:\n        () => ({ state, dispatch }) => {\n          return goToNextCell(-1)(state, dispatch)\n        },\n      fixTables:\n        () => ({ state, dispatch }) => {\n          if (dispatch) {\n            fixTables(state)\n          }\n\n          return true\n        },\n      setCellSelection:\n        position => ({ tr, dispatch }) => {\n          if (dispatch) {\n            const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell)\n\n            // @ts-ignore\n            tr.setSelection(selection)\n          }\n\n          return true\n        },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Tab: () => {\n        if (this.editor.commands.goToNextCell()) {\n          return true\n        }\n\n        if (!this.editor.can().addRowAfter()) {\n          return false\n        }\n\n        return this.editor.chain().addRowAfter().goToNextCell().run()\n      },\n      'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n      Backspace: deleteTableWhenAllCellsSelected,\n      'Mod-Backspace': deleteTableWhenAllCellsSelected,\n      Delete: deleteTableWhenAllCellsSelected,\n      'Mod-Delete': deleteTableWhenAllCellsSelected,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const isResizable = this.options.resizable && this.editor.isEditable\n\n    return [\n      ...(isResizable\n        ? [\n          columnResizing({\n            handleWidth: this.options.handleWidth,\n            cellMinWidth: this.options.cellMinWidth,\n            defaultCellMinWidth: this.options.cellMinWidth,\n            View: this.options.View,\n            lastColumnResizable: this.options.lastColumnResizable,\n          }),\n        ]\n        : []),\n      tableEditing({\n        allowTableNodeSelection: this.options.allowTableNodeSelection,\n      }),\n    ]\n  },\n\n  extendNodeSchema(extension) {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    return {\n      tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n    }\n  },\n})\n"],"names":["CellSelection","findParentNodeClosestToPos","Node","mergeAttributes","TextSelection","addColumnBefore","addColumnAfter","deleteColumn","addRowBefore","addRowAfter","deleteRow","deleteTable","mergeCells","splitCell","toggleHeader","toggleHeaderCell","setCellAttr","goToNextCell","fixTables","columnResizing","tableEditing","callOrReturn","getExtensionField"],"mappings":"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"}